<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>seanchann's blog</title><link>http://seanchann.github.io/</link><description></description><atom:link href="http://seanchann.github.io/feeds/all.rss.xml" rel="self"></atom:link><lastBuildDate>Fri, 03 Jul 2015 00:00:00 +0800</lastBuildDate><item><title>httpproxy2socket</title><link>http://seanchann.github.io/httpproxy2socket-cn.html</link><description>&lt;p&gt;&lt;strong&gt;系统：Fedora 22&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个需求的来源是无法通过shadowsocket的方式给其他的应用提供http proxy。大量的程序目前都是可以配置http proxy，而不是socket4或者socket5的方式。因此促使我做了一下这方面的工作，把我的经验分享给大家。&lt;/p&gt;
&lt;p&gt;前提条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;shadowsocket已经配置完成并可用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;方案描述&lt;/h2&gt;
&lt;p&gt;我的方案就是搭建socket5代理、http代理，最终通过proxychains将这个两个代理连接。&lt;/p&gt;
&lt;p&gt;socket5的代理就是我们需要提前配置好的shadowsocket的环境，它给本地提供了一个默认端口为1080的socket5的代理。这个代理是可以让我们自由的畅享Internet的。。。&lt;/p&gt;
&lt;p&gt;http proxy我们通过squid来实现&lt;/p&gt;
&lt;p&gt;proxychains主要用组装我们的代理链条。&lt;/p&gt;
&lt;h2&gt;squid&lt;/h2&gt;
&lt;p&gt;squid可以配置为一个http proxy server，并且有相关的权限控制。我们用它来作为本地的http proxy。&lt;/p&gt;
&lt;p&gt;安装squid：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;dnf install squid
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;配置squid：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;vi /etc/squid/squid.conf
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们增加一些必要的基本配置：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;acl http_proxy src 192.168.1.0/24
http_access allow http_proxy
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的这个配置许可192.168.1.0/24网络内对此http proxy的访问。
在配置文件中，也可以看到默认的监听端口是3182&lt;/p&gt;
&lt;p&gt;使能开机启动以及启动服务：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;systemctl &lt;span class="nb"&gt;enable &lt;/span&gt;squid.service
systemctl start squid.service
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;注意：如果你使能了iptables，那么配置3128端口的路由规则&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;proxychains&lt;/h2&gt;
&lt;p&gt;proxychains可以为我们提供强大的代理链条。我们来配置我们的http proxy再连接到socket5。完成我们最初的设想。&lt;/p&gt;
&lt;p&gt;安装proxychains：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;dnf install  proxychains
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;proxychains的配置文件的查找优先级：&lt;/p&gt;
&lt;p&gt;1 ./proxychains.conf
2 $(HOME)/.proxychains/proxychains.conf
3 /etc/proxychains.conf **&lt;/p&gt;
&lt;p&gt;推荐在用户目录创建&lt;/p&gt;
&lt;p&gt;完成以后，我们配置proxychains.conf，增加如下的内容：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;[ProxyList]
# add proxy here ...
# meanwile
# defaults set to &amp;quot;tor&amp;quot;
http 192.168.1.2 3128
socks5  192.168.1.2 1080
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的配置文件的含义是，请求首先进入http proxy，随后再通过socket5到达目的地。&lt;/p&gt;
&lt;p&gt;使用范例：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;proxychains wget www.test.com
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Seanchann Zhou</dc:creator><pubDate>Fri, 03 Jul 2015 00:00:00 +0800</pubDate><guid>tag:seanchann.github.io,2015-07-03:httpproxy2socket-cn.html</guid><category>httpproxy socket</category></item><item><title>jenkins-docker</title><link>http://seanchann.github.io/jenkins-docker-cn.html</link><description>&lt;p&gt;&lt;strong&gt;系统：CentOS7 + docker 1.6&lt;/strong&gt;
&lt;strong&gt;Jenkins: ver. 1.609.1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;jenkins在使用中碰到的问题的汇总，以备查阅。&lt;/p&gt;
&lt;h2&gt;jenkins  (pending—Waiting for next available executor)&lt;/h2&gt;
&lt;p&gt;检查下节点的状态，当master node如果disk不足，就会自动的把master node切换到离线，如果有job被触发，那么将此job置为pending。&lt;/p&gt;
&lt;h2&gt;Disk space is too low. Only 0.519GB left on /tmp&lt;/h2&gt;
&lt;p&gt;在docker镜像里，/tmp分区确实很小，因此，总是会把master节点置为offline，我们在启动的时候传入下面的环境变量来修改tmpdir：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;JAVA_OPTS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;-Djava.io.tmpdir=&lt;/span&gt;&lt;span class="nv"&gt;$JENKINS_HOME&lt;/span&gt;&lt;span class="s2"&gt;/tmp&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Seanchann Zhou</dc:creator><pubDate>Fri, 03 Jul 2015 00:00:00 +0800</pubDate><guid>tag:seanchann.github.io,2015-07-03:jenkins-docker-cn.html</guid><category>jenkins</category></item><item><title>jenkins-docker-build</title><link>http://seanchann.github.io/jenkins-docker-build-cn.html</link><description>&lt;p&gt;&lt;strong&gt;系统：CentOS7 + docker 1.6&lt;/strong&gt;
&lt;strong&gt;Jenkins: ver. 1.609.1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前提条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jenkins的任意node已经安装docker或者docker-build-step插件已经安装&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先，完成docker img编译相关的job有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过docker-build-setup等类似插件来完成&lt;/li&gt;
&lt;li&gt;通过执行脚本来完成，前提是我们的node上已经有docker环境。这个node当然也可以是docker-slave了，这样就会更加的灵活了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;配置docker build step 插件&lt;/h2&gt;
&lt;p&gt;docker build step的原理是配置一个Docker Remote API，插件通过这个API来进行docker命令的相关操作。&lt;/p&gt;
&lt;p&gt;这个插件的配置是在configuration
--&amp;gt;Docker Builder选项中配置一下docker Remote API，比如：http://192.168.60.79:2375&lt;/p&gt;
&lt;p&gt;配置完成后，就可以在job的build step里面选择“Execute Docker container”配置相应的命令，来完成你的工作。&lt;/p&gt;
&lt;h2&gt;配置一个节点&lt;/h2&gt;
&lt;p&gt;参照标准的节点操作来添加一个有docker环境的node。&lt;/p&gt;
&lt;p&gt;节点配置完成后，我们在job的configure制定我们的slave node，那么就可以在这个docker node里面执行我们的docker相关的工作了。&lt;/p&gt;
&lt;p&gt;这里你也可以尝试下使用docker in docker的方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：node上必须有jdk的环境，以及git等相关软件，根据需要自行安装&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Seanchann Zhou</dc:creator><pubDate>Fri, 03 Jul 2015 00:00:00 +0800</pubDate><guid>tag:seanchann.github.io,2015-07-03:jenkins-docker-build-cn.html</guid><category>jenkins</category></item><item><title>jenkins-docker-slave</title><link>http://seanchann.github.io/jenkins-docker-slave-cn.html</link><description>&lt;p&gt;&lt;strong&gt;系统：CentOS7 + docker 1.6&lt;/strong&gt;
&lt;strong&gt;Jenkins: ver. 1.609.1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://seanchann.github.io/jenkins-gitlab-cn.html"&gt;前面的章节已经成功的通过git push触发job&lt;/a&gt;，本章我们配置一个job，在docker cloud中执行这些job&lt;/p&gt;
&lt;p&gt;前提条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jenkins的docker-plugin插件已经安装&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;jenkins与docker协同工作的原理是，通过jenkins的docker插件来完成。
首先docker插件负责docker daemon的管理，也就是配置jenkins去连接docker daemon。然后启动一个docker image来完成job。其中，需要注意的是后续我们的job都是完全放在这个启动起来的container里面完成的。因此这个image需要我们自己去根据工程的需要来定义。还有就是master会去连接到这个启动起来的container，是通过ssh来连接的。&lt;/p&gt;
&lt;h2&gt;配置docker plugin&lt;/h2&gt;
&lt;p&gt;docker 插件提供了可以通过在slave的节点上docker环境，来执行docker的相关操作。&lt;/p&gt;
&lt;h3&gt;docker环境配置&lt;/h3&gt;
&lt;p&gt;这里主要就是配置下docker daemon，首先使我们必须安装完成docker。
对docker daemon的配置流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/etc/sysconfig/docker配置文件配置OPTIONS='-H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375' 。这个配置使能了本地socket以及远端tcp的连接。&lt;/li&gt;
&lt;li&gt;如果有防火墙，配置防火墙打开2375端口（no auth）以及2376端口（auth）&lt;/li&gt;
&lt;li&gt;重启防火墙以及我们的docker.service&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;注意-H给出的端口作为http端口，端口+1作为https，这是docker daemon的默认行为&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;docker jenkins image&lt;/h3&gt;
&lt;p&gt;配置好docker daemon以后，还需要在docker slave上跑一个docker image给jenkins来使用。后面去配置jenkins的docker cloud的时候就是配置这个image。&lt;/p&gt;
&lt;p&gt;这个image的创建可以手动创建或者直接使用docker hub上的evarga/jenkins-slave&lt;/p&gt;
&lt;h4&gt;evarga/jenkins-slave的使用&lt;/h4&gt;
&lt;p&gt;这个镜像直接拉取：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;docker pull evarga/jenkins-slave
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;镜像默认的用户名和密码是jenkins:jenkins&lt;/p&gt;
&lt;h4&gt;手动创建jenkins-slave&lt;/h4&gt;
&lt;h1&gt;jenkins的配置&lt;/h1&gt;
&lt;p&gt;jenkins的配置主要包括增加一个docker cloud。&lt;/p&gt;
&lt;h4&gt;docker cloud的配置，&lt;/h4&gt;
&lt;p&gt;流程描述如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Manage Jenkins-&amp;gt;configuration-&amp;gt;Add New cloud&lt;/li&gt;
&lt;li&gt;配置name以及 Docker URL（eg.http://dockerdaemonip:2375）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面流程配置完成后，会在Mnage Jenkins--&amp;gt;Docker页面看到我们配置的docker server以及它的状态。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Seanchann Zhou</dc:creator><pubDate>Fri, 03 Jul 2015 00:00:00 +0800</pubDate><guid>tag:seanchann.github.io,2015-07-03:jenkins-docker-slave-cn.html</guid><category>jenkins</category></item><item><title>jenkins-gitlab</title><link>http://seanchann.github.io/jenkins-gitlab-cn.html</link><description>&lt;p&gt;&lt;strong&gt;系统：CentOS7 + docker 1.6&lt;/strong&gt;
&lt;strong&gt;Jenkins: ver. 1.609.1&lt;/strong&gt;
&lt;strong&gt;gitlab: 6.8.1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文主要针对jenkins与gitlab的整合进行说明。&lt;/p&gt;
&lt;p&gt;前提条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jenkins的 git、git-client、gitlab-hook插件已经安装&lt;/li&gt;
&lt;li&gt;gitlab已经安装成功&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;jenkins的配置&lt;/h2&gt;
&lt;h3&gt;create jobs&lt;/h3&gt;
&lt;p&gt;创建一个任务其中需要注意的地方是，配置下自己的git ssh key&lt;/p&gt;
&lt;h4&gt;Source Code Management&lt;/h4&gt;
&lt;p&gt;此项配置主要是对我们代码库的配置，我们配置为git，然后给出我们的git 仓库的url，切记这里需要配置下证书，我们选择的方式ssh key的方式&lt;/p&gt;
&lt;h4&gt;Build Triggers的配置&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Poll SCM：也就是给一个周期来自动的拉取整个的workspace，如果要避免这样做，那么就给出一个push的触发。我们这里的schedule什么都不配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;gitlab webhook的配置&lt;/h2&gt;
&lt;p&gt;登录到gitlab管理页面，给git-test工程增加一个push event的hook，url填写：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;http://yourjenkinshome/git/notifyCommit?url=git@192.168.60.18:xqzhou/git-test.git
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;配置完成后，我们在gitlab上点击testlink，触发到jenkins成功，表示我们的配置是ok的。&lt;/p&gt;
&lt;h3&gt;gitlab push event的额外配置&lt;/h3&gt;
&lt;p&gt;在我使用的gitlab的版本上，当git客户端去git push的时候，不能触发hook，必须在gitlab的每个仓库中的hooks目录增加一个post-receive的脚本：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;

curl http://yourjenkins/git/notifyCommit?url&lt;span class="o"&gt;=&lt;/span&gt;your-gitrepos-url
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样配置以后，才可以正常的在jenkins中触发我们的job。&lt;/p&gt;
&lt;p&gt;并且这个触发可以支持分支的build，需要在jenkins的job中增加需要编译的分支。git插件提供了一些有用的变量，可以在我们的脚本中使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$GIT_BRANCH：返回分支名&lt;/li&gt;
&lt;li&gt;$GIT_COMMIT：git的commit id&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Seanchann Zhou</dc:creator><pubDate>Fri, 03 Jul 2015 00:00:00 +0800</pubDate><guid>tag:seanchann.github.io,2015-07-03:jenkins-gitlab-cn.html</guid><category>jenkins</category></item><item><title>jenkins-install</title><link>http://seanchann.github.io/jenkins-install-cn.html</link><description>&lt;p&gt;&lt;strong&gt;系统：CentOS7 + docker 1.6&lt;/strong&gt;
&lt;strong&gt;Jenkins: ver. 1.609.1&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;对于jenkins的安装，直接使用dockerhub上的镜像进行构建。直接docker pull jenkins就可以了。&lt;/p&gt;
&lt;h2&gt;jenkins的插件安装&lt;/h2&gt;
&lt;p&gt;对于插件安装，有两种方式，通过页面安装或者直接安装在docker image里面。
一般来说，我们采用后一种方式来安装。避免插件的反复安装。&lt;/p&gt;
&lt;p&gt;重新编译一个docker image，Dockerfile片段：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;FROM jenkins
COPY plugins.txt /usr/share/jenkins/plugins.txt
RUN /usr/local/bin/plugins.sh /usr/share/jenkins/plugins.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;复制了一个plugins.txt文件，这个文件的内容如下：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;git:latest
git-client:latest
gitlab-hook:latest
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的这些就是我们要安装的插件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：在安装插件的时候，保证插件依赖的插件也被正确的安装，否则这些插件是不可用的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://wiki.jenkins-ci.org/display/JENKINS/"&gt;插件依赖可参考这里&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Seanchann Zhou</dc:creator><pubDate>Fri, 03 Jul 2015 00:00:00 +0800</pubDate><guid>tag:seanchann.github.io,2015-07-03:jenkins-install-cn.html</guid><category>jenkins</category></item><item><title>jenkins-security</title><link>http://seanchann.github.io/jenkins-security-cn.html</link><description>&lt;p&gt;&lt;strong&gt;系统：CentOS7 + docker 1.6&lt;/strong&gt;
&lt;strong&gt;Jenkins: ver. 1.609.1&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;配置说明&lt;/h2&gt;
&lt;p&gt;jenkins的安全配置说明在主页面的Configure Global Security的菜单中。它的安全和访问控制主要是两部分：安全域和鉴权策略。&lt;/p&gt;
&lt;h3&gt;Security Realm配置&lt;/h3&gt;
&lt;p&gt;在这个配置中，包含了下列的子选项，我们一一进行分析和说明：&lt;/p&gt;
&lt;h4&gt;Delegate to servlet container&lt;/h4&gt;
&lt;p&gt;使用servlet container对用户授权。这个是有历史的，从1.163版本就支持了这个功能。它主要用于下面的情节：
&lt;em&gt; 从1.164就开始使用jenkins，并且不想改变当前的状态。
&lt;/em&gt; 你已经配置了servlet container的鉴权，并且希望jenkins直接使用它&lt;/p&gt;
&lt;h4&gt;Jenkins's own user database&lt;/h4&gt;
&lt;p&gt;使用jenkins自己的用户列表来授权。这个适合小型范围的配置当你并没有任何的用户数据库的时候，当有大量用户的时候，这种策略是不合适的。在这种策略下，如果允许任何人通过注册可以获取到jenkins的权限的话，可以勾上“Allow user to sign up”。这样非用户可以自己通过“sign up”来注册使用jenkins。如果不允许，那么此时想添加新的用户，只能由注已经注册用户通过Manage Jenkins--&amp;gt; Manage Users进入User Database界面，来创建用户。&lt;/p&gt;
&lt;h4&gt;LDAP&lt;/h4&gt;
&lt;p&gt;顾名思义连接到你已经有的ldap服务器来配置&lt;/p&gt;
&lt;h4&gt;Unix user/group database&lt;/h4&gt;
&lt;p&gt;如果安装的机器是unix机器，可以使用unix的账户信息来登录到jenkins。&lt;/p&gt;
&lt;h3&gt;Authorization 配置&lt;/h3&gt;
&lt;p&gt;鉴权策略的话，也有几个子选项。&lt;/p&gt;
&lt;h4&gt;Anyone can do anything&lt;/h4&gt;
&lt;p&gt;任何人都可以在系统上进行任何的操作。不推荐的方式&lt;/p&gt;
&lt;h4&gt;Legacy mode&lt;/h4&gt;
&lt;p&gt;这种策略比较极端：admin用户拥有所有权限，其他用户只读。&lt;/p&gt;
&lt;h4&gt;Logged-in users can do anything&lt;/h4&gt;
&lt;p&gt;可登录的用户拥有所有操作的权限。&lt;/p&gt;
&lt;h4&gt;Matrix-based security&lt;/h4&gt;
&lt;p&gt;默认首次启动后，配置administrator用户，配置系统所有权限，再对其他用户配置相应的权限。可实现admin对所有用户的权限的集中管制&lt;/p&gt;
&lt;h4&gt;Project-based Matrix Authorization Strategy&lt;/h4&gt;
&lt;p&gt;这个是针对每个工程配置权限，上节描述的是针对整个系统的。此项针对每个用户在每个具体的project上的权限进行配置。&lt;/p&gt;
&lt;h3&gt;Matrix-based security配置系统&lt;/h3&gt;
&lt;p&gt;我们使用Matrix-base sercurity来配置我们的用户系统，对用户进行集中管理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;勾选Enable Security&lt;/li&gt;
&lt;li&gt;Security Realm选择“Jenkins’ own user” database，确保勾选了“Allow users to sign up”&lt;/li&gt;
&lt;li&gt;Authorization选择“Matrix-based security”&lt;/li&gt;
&lt;li&gt;save &amp;amp;&amp;amp; apply&lt;/li&gt;
&lt;li&gt;随后“sign up”创建一个新的用户admin。&lt;/li&gt;
&lt;li&gt;在“Matrix-based security”中为admin用户配置所有的权限&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;补充说明&lt;/h2&gt;
&lt;h3&gt;权限配置错误，导致无法登陆的问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;停止jenkins&lt;/li&gt;
&lt;li&gt;修改$JENKINS_HOME目录下的congfig.xml&lt;/li&gt;
&lt;li&gt;将标签&lt;useSecurity&gt;true&lt;/useSecurity&gt;改为false&lt;/li&gt;
&lt;li&gt;将标签&lt;AuthorizationStrategy&gt;以及&lt;securityRealm&gt;这两个标签删除&lt;/li&gt;
&lt;li&gt;重新启动jenkins&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Seanchann Zhou</dc:creator><pubDate>Fri, 03 Jul 2015 00:00:00 +0800</pubDate><guid>tag:seanchann.github.io,2015-07-03:jenkins-security-cn.html</guid><category>jenkins</category></item><item><title>mongodb---install</title><link>http://seanchann.github.io/mongodb-install-cn.html</link><description>&lt;p&gt;&lt;strong&gt;系统：CentOS7 + docker 1.6&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mongodb版本： 3.0.2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文的安装是采用docker的方式，而不是在os上安装package的方式。
&lt;a href="http://docs.mongoing.com/manual/tutorial/"&gt;package的安装方式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在开始前，假定用户已经完成了基础环境的配置，这里主要是指docker的运行环境&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;h3&gt;运行一个mongodb&lt;/h3&gt;
&lt;p&gt;docker hub上官方的mongodb image，我们直接使用此image来运行mongodb：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;docker pull mongo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;创建一个volume容器，保存mongo的数据以及配置：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;docker create -v /yourdir/mongo/data/db:/data/db -v /yourdir/mongo/conf/:/conf/ --name&lt;span class="o"&gt;=&lt;/span&gt;mongo-dv mongo
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;run mongodb with volume&lt;/h3&gt;
&lt;p&gt;直接指定绑定host上的文件夹：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;docker create --volumes-from&lt;span class="o"&gt;=&lt;/span&gt;mongo-dv --name mongodb -d mongo
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;自定义参数启动&lt;/h3&gt;
&lt;p&gt;docker hub上提供的官方镜像支持自定义参数启动mongodb：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;docker run -p 27017:27017 --name&lt;span class="o"&gt;=&lt;/span&gt;mongodb -d mongo  --auth
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如上所示，我们传入了--auth给run命令做为参数，相当于我们执行mongod --auth&lt;/p&gt;
&lt;p&gt;截取一段代码看看：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt; -e

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nv"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nv"&gt;1&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;-&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
        &lt;span class="nb"&gt;set&lt;/span&gt; -- mongod &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;mongod&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
        chown -R mongodb /data/db

        &lt;span class="nv"&gt;numa&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;numactl --interleave=all&amp;#39;&lt;/span&gt;

        &lt;span class="nb"&gt;exec &lt;/span&gt;gosu mongodb &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;

&lt;span class="nb"&gt;exec&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此段脚本的流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;检查参数列表中的第一个参数，偏移为0，也就是取第一个参数的第一个字符，如果是‘-’，那么在参数列表前面添加‘mongod’。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果检测到第一个参数是‘mongod’，那么将‘numactl --interleave=all’压入参数列表。在上一步中，如果传入了参数，那么就参数列表中第一个参数肯定是‘mongod’；如果没有传入参数，在Dockerfile中的CMD默认是'mongod'。因此此步肯定会执行到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后，我们执行压入参数列表中的命令。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;完整的启动命令&lt;/h3&gt;
&lt;p&gt;经过上面的推敲，通过docker启动mongodb的完整命令应该是：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;docker run -p 27017:27017 --volumes-from=mongo-dv --name=mongodb -d mongo --auth
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Seanchann Zhou</dc:creator><pubDate>Fri, 03 Jul 2015 00:00:00 +0800</pubDate><guid>tag:seanchann.github.io,2015-07-03:mongodb-install-cn.html</guid><category>mongodb</category></item><item><title>mongodb---Problems Summary</title><link>http://seanchann.github.io/mongodb-problems-summary-cn.html</link><description>&lt;p&gt;&lt;strong&gt;系统：CentOS7 + docker 1.6&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mongodb版本： 3.0.2&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;WARNING:/sys/kernel/mm/transparent_hugepage/enabled or /sys/kernel/mm/transparent_hugepage/defrag is 'always'.&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    这个问题的原因是由于内核的某些参数的配置造成的mongodb产生了警告，基于docker环境，在docker运行的host主机上：

    1. echo never &amp;gt; /sys/kernel/mm/transparent_hugepage/enabled
    2. echo never &amp;gt; /sys/kernel/mm/transparent_hugepage/defrag

    or

    1. echo never | sudo tee /sys/kernel/mm/transparent_hugepage/enabled
    2. echo never | sudo tee /sys/kernel/mm/transparent_hugepage/defrag
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;run command with db&lt;/h2&gt;
&lt;p&gt;从mongo shell执行db.runCommand()，需要添加下面的用户以及权限才能执行。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;db.createUser(
  {
    user: &amp;quot;admin&amp;quot;,
    pwd: &amp;quot;password&amp;quot;,
    roles: [ { role: &amp;quot;root&amp;quot;, db: &amp;quot;admin&amp;quot; } ]
  }
);
exit; 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 0.0_="0.0," 18="18" _auth="&amp;quot;auth" code:="code:" errmsg:="errmsg:" failed_="failed&amp;quot;," ok:="ok:"&gt;db.auth() 错误：Error: 18&lt;/h2&gt;
&lt;p&gt;从本地mongo shell 可以正常的auth，从远端始终无法auth成功。想了又想，弄了又弄，就是不见好。&lt;/p&gt;
&lt;p&gt;后来，竟然发现是因为远端系统的mongo shell的版本太低了。这个坑有点太坑了，shell都不兼容的吗？&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Seanchann Zhou</dc:creator><pubDate>Fri, 03 Jul 2015 00:00:00 +0800</pubDate><guid>tag:seanchann.github.io,2015-07-03:mongodb-problems-summary-cn.html</guid><category>mongodb</category></item><item><title>mongodb---user</title><link>http://seanchann.github.io/mongodb-user-cn.html</link><description>&lt;p&gt;&lt;strong&gt;系统：CentOS7 + docker 1.6&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mongodb版本： 3.0.2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装工作完成后，整个的mongodb运行起来后，在开始工作前，首先应该为我们的mongodb配置适当的用户以及其权限。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意下，网上大多数的直接进入命令行,执行：&lt;/em&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;use admin
db.adduser(&amp;quot;test&amp;quot;,&amp;quot;123&amp;quot;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;上面这种方式在3.0的版本上是行不通的&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;添加管理员用户&lt;/h2&gt;
&lt;p&gt;通过docker首先启动不带--auth的mongodb：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;docker run --volumes-from=mongodb-dv --name mongodb -d mongo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://seanchann.github.io/mongodb-install-cn.html"&gt;更详细的对安装的描述&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;进入mongo shell&lt;/h3&gt;
&lt;h3&gt;添加管理员用户：&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;use admin
db.createUser(
{
      user: &amp;quot;admin&amp;quot;,
      pwd: &amp;quot;admin&amp;quot;,
      roles: [ { role: &amp;quot;userAdminAnyDatabase&amp;quot;, db: &amp;quot;admin&amp;quot; } ]
})
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;roles字段的说明：添加管理员用户的时候，提供了两种roles：userAdmin以及userAdminAnyDatabase&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;userAdmin：提供去创建和修改当前数据库的roles以及user。这个role也间接的提供了superuser给我们去访问数据库或者其他，如果当前数据库是admin 数据库，cluster数据库。userAdmin role允许用户去更改其他用户的权限，当然也包括他们自己。它支持操作有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;changeCustomData&lt;/li&gt;
&lt;li&gt;changePassword&lt;/li&gt;
&lt;li&gt;createRole&lt;/li&gt;
&lt;li&gt;createUser&lt;/li&gt;
&lt;li&gt;dropRole&lt;/li&gt;
&lt;li&gt;dropUser&lt;/li&gt;
&lt;li&gt;grantRole&lt;/li&gt;
&lt;li&gt;revokeRole&lt;/li&gt;
&lt;li&gt;viewRole&lt;/li&gt;
&lt;li&gt;viewUser&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;userAdminAnyDatabase: 这个role与userAdmin支持的权限类似，但是它应用的对象是在整个集群中的数据库。这个role也提供了下面可以在集群中使用的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;authSchemaUpgrade&lt;/li&gt;
&lt;li&gt;invalidateUserCache&lt;/li&gt;
&lt;li&gt;listDatabases&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;检查创建的用户&lt;/h3&gt;
&lt;p&gt;根据前面的命令，我们的应该有了一个admin的用户，执行命令检查下：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;show users
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们得到的输出是：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;_id&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;admin.admin&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;user&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;admin&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;db&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;admin&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;roles&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
                &lt;span class="p"&gt;{&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;quot;role&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;userAdminAnyDatabase&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;quot;db&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;admin&amp;quot;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同样的，我们也可以使用命令：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  db.system.users.find()
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;重新启动mongodb with auth parameter&lt;/h3&gt;
&lt;p&gt;接下来，我们重新启动一个mongodb，使用--auth：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;docker run --volumes-from&lt;span class="o"&gt;=&lt;/span&gt;mongodb_data --name mongodb -d mongo --auth
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;执行下面的命令，检查鉴权是否可以成功：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;use admin
db.auth(&amp;quot;admin&amp;quot;,&amp;quot;admin&amp;quot;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;执行后返回的结果是：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这表示我们的执行用户鉴权是成功的&lt;/p&gt;
&lt;p&gt;到此，管理数据库用户的用户admin创建成功，接下来就是创建针对每个数据库的用户&lt;/p&gt;
&lt;h3&gt;创建数据库用户&lt;/h3&gt;
&lt;p&gt;我们先来执行下面的命令，创建一个数据库test：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;use test
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;创建test数据库的用户test,这里给的role是readWrite：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;db.createUser({user:&amp;quot;test&amp;quot;, pwd:&amp;quot;test&amp;quot;, roles:[{role:&amp;quot;readWrite&amp;quot;,db:&amp;quot;test&amp;quot;}]})
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们对用户进行下鉴权：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;db.auth(&amp;quot;test&amp;quot;,&amp;quot;test&amp;quot;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果返回为：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那对test数据库创建的test用户是ok的，随后在test的数据库中，就可以使用test用户对此数据库进行读写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关资源链接：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;a href="http://docs.mongodb.org/manual/reference/built-in-roles"&gt;mongodb role相关内容参考&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Seanchann Zhou</dc:creator><pubDate>Fri, 03 Jul 2015 00:00:00 +0800</pubDate><guid>tag:seanchann.github.io,2015-07-03:mongodb-user-cn.html</guid><category>mongodb</category></item><item><title>go-reflect</title><link>http://seanchann.github.io/go-reflect-cn.html</link><description>&lt;p&gt;&lt;a href="http://blog.golang.org/laws-of-reflection"&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;反射规则&lt;/h2&gt;
&lt;h3&gt;反射规则的第一条：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.反射从interface的value到reflection object
  在底层，反射仅仅是一个机制，来检查存储在内部的一个interface变量中的type和value的对。首先，在包reflect中有两种类型我们必须知晓：Type 以及 Value。这两个类型可以让我们访问到interface变量的内容，并且提供了两个简单的函数，reflect.TypeOf以及reflect.ValueOf,通过对这两个函数的调用就可以获取到interface变量的值。（此外，调用reflect.Value也非常容易获取到reflect.Type,但是在概念上Value以及Type是完全不同的）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;让我们先开始使用下TypeOf:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;
  &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;reflect&amp;quot;&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

  &lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="kt"&gt;float64&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.4&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;type:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TypeOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个程序会打印：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  type: float64
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你可能会想知道我们的interface在哪里，因为上面的程序看上去就像是它传递了float64给变量x，而不是一个interface的value，传递给我们的reflect.TypeOf。但是它确实是存在的；在godoc文档中，reflect.TypeOf的签名包含一个空的interface：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;// TypeOf returns the reflection Type of the value in the interface{}.&lt;/span&gt;
  &lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;TypeOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="p"&gt;{})&lt;/span&gt; &lt;span class="nx"&gt;Type&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当我们调用reflect.TypeOf(x),x是第一个被存储在空interface中，然后传入作为参数；reflect.TypeOf打开这个空的interface，然后重新获取type的信息。&lt;/p&gt;
&lt;p&gt;reflect.Valueof 函数，当然，也重新获取value&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="kt"&gt;float64&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.4&lt;/span&gt;
  &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;value:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ValueOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;程序输出：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  value: &amp;lt;float64 Value&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;reflect.Type以及reflect.Value两个都提供了很多的方法让我们去检查和操作它们。一个重要的例子是Value有一个Type的方法来返回一个reflect.Value的Type。还有Type以及Value都有一个Kind的方法，这个方法返回一个恒量，这个恒量是按照一定的顺序被存储：Unit，Float64，Slice，等等。另外Value提供了一些方法，这些方法名类似Int以及Float，可以让我们获取在这些对象的内部存储的值：（就像int64以及float64）：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="kt"&gt;float64&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.4&lt;/span&gt;
  &lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ValueOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;type:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
  &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;kind is float64:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Kind&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Float64&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;value:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Float&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  type: float64
  kind is float64: true
  value: 3.4
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里也有一些方法类似于SetInt以及SetFloat，使用它们的时候，我们必须理解reflect的设置能力，下面的内容将会讲到。
  反射库有一些比较有用的属性。首先，保持API的简单，Value的方法“getter”以及“setter”操作，可以容纳比较大的类型的值：例如,针对所有的有符号整型int64。也就是说，Value的Int方法返回一个int64的值，以及SetInt可以接受int64的参数；那么可能我们需要将它们转换为实际的所需要的类型。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="kt"&gt;uint8&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;
  &lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ValueOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;type:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;           &lt;span class="c1"&gt;// uint8.&lt;/span&gt;
  &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;kind is uint8: &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Kind&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Uint8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// true.&lt;/span&gt;
  &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;uint8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Uint&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;      &lt;span class="c1"&gt;// v.Uint returns a uint64.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二个属性就是reflect对象的Kind描述的是最基本的类型，而不是静态类型。如果一个反射对象包含了用户自定义的integer类型，就像：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;MyInt&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
  &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="nx"&gt;MyInt&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;
  &lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ValueOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;v的kind将会是reflect.Int，即使我们x的类型是MyInt，而不是int。换句话说，Kind不能区分从一个MyInt到Int，即使在类型上看它们是不同的。&lt;/p&gt;
&lt;h3&gt;反射的第二条规则&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2.反射从反射的对象到interface的值
  类似于物理反射，反射在Go中生成它自己的反面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给出一个reflect.Value我们可以获取到interface的值使用Interface的方法；实际上，此方法打包了type以及value的信息以一个interface的来表现并且返回结果。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;// Interface returns v&amp;#39;s value as an interface{}.&lt;/span&gt;
  &lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="nx"&gt;Value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nx"&gt;Interface&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;作为一个推论我们可以有：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="nx"&gt;y&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Interface&lt;/span&gt;&lt;span class="p"&gt;().(&lt;/span&gt;&lt;span class="kt"&gt;float64&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// y will have type float64.&lt;/span&gt;
  &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过反射对象v来打印float64值的表现&lt;/p&gt;
&lt;p&gt;我们可以做的更好。fmt.Println,fmt.Printf的参数都是一个空的interface的值，然后在fmt包的内部做解包，就跟我们前面讲的例子一样。因此，我们可以打印出reflect.Value：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Interface&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（为什么不直接fmt.Println(v)?因为v是一个reflect.Value的类型。我们想要它保存的正确的值。）由于我们的值是一个float64，我们可以格式化float的输出：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;value is %7.1e\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Interface&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  3.4e+00
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;再次，这里不需要v.Interface()到float64的类型的断言；空的interface的值在里面有具体的类型信息，并且Printf会重新恢复它。
  总之，Interface的方法是ValueOf函数的逆操作，不同的地方就是它的结果始终是静态类型interface{}
  重申：反射从interface的值到反射的对象，并且也可以返回。&lt;/p&gt;
&lt;h3&gt;反射的第三个规则&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;3.修改一个反射对象，值必须是可修改的。
  第三条规则非常的让人困惑并且难以理解，但是也是很容易理解的，如果我们是从第一个原理开始的学习。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里有一些代码不能工作，但是它对学习此规则很有用：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="kt"&gt;float64&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.4&lt;/span&gt;
  &lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ValueOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;SetFloat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;7.1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Error: will panic.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你运行这个代码，程序将会panic：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  panic: reflect.Value.SetFloat using unaddressable value
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个问题不在于值7.1，而在于这个值无法寻址。它的v是不可设置的。设置能力是反射的Value的属性，但是不是所有的反射Values都有此能力。
  Value的CanSet的方法可以给出Value的设置能力。在我们的例子里：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="kt"&gt;float64&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.4&lt;/span&gt;
  &lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ValueOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;settability of v:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;CanSet&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打印：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  settability of v: false
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不能对不具有设置能力的Value调用Set方法。但是什么是设置能力那？
  设置能力有点像寻址能力，但是它更严格。它是一个反射对象的属性，可以用来修改被创建这个反射对象的实际的存储的数据。设置能力通过是否反射对象保存了原始的条目来确定。那么：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="kt"&gt;float64&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.4&lt;/span&gt;
  &lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ValueOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们传入了一个x的copy给reflect.ValueOf,因此对传入给relfect.ValueOf的x的copy的参数，创建了一个interface，这里不是x自己。因此，语句：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;SetFloat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;7.1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;是可以成功的，它不会去更新x，即使看上去它是从x创建的。相反，它将会更新存在在反射的值的x的copy，x本身不会受到影响。这将会引起混乱，因此它是非法的，设置能力就是为了避免类似的问题。
  如果这个看上去比较奇怪，实际上不是。实际上这是一个我们熟悉的情况，但是有不寻常的表述。考虑一个传入x参数的函数：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们不期望f可以去修改我们的x，因为我们传递的是x的值拷贝，而不是x自己。如果我们想要修改x，那么我们必须传递的是对x的引用：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这是比较简单和熟悉的，并且反射的工作原理与这个类似。如果我们想要通过反射来修改x，我们必须给反射库提供一个指向我们想要修改的变量的指针。
  让我们来实践下。首先初始化x，然后创建一个reflect的value指向它，称它为p：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="kt"&gt;float64&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.4&lt;/span&gt;
  &lt;span class="nx"&gt;p&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ValueOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Note: take the address of x.&lt;/span&gt;
  &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;type of p:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
  &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;settability of p:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;CanSet&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么输出是：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  type of p: *float64
  settability of p: false
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;反射对象p是不可修改的，但是这个不是我们修改的p。它是*p。获取到p指向哪里，我们调用Value的Elem的方法，它直接获取到指针，并且保存结果再反射的Value，我们称之为v：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Elem&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;settability of v:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;CanSet&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在v是一个可以设置修改的反射对象了：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  settability of v: true
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于它就是指向x的，我们最终调用v.SetFloat来修改x的值：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;SetFloat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;7.1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Interface&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
  &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出是：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  7.1
  7.1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;反射可能难以理解，但是它是语言层面实现的，这些掩饰了反射的Types以及Values背后的逻辑。我们只需记住，反射的Values需要想要修改的对象的地址来进行修改它们的值。
  structs
  在我们的前面的例子中v本身不是一个指针，它只是由一个指针创建。使用反射去修改结构的字段的常用方法。只要我们有结构实例的地址，我们就可以修改它的字段。
  这里有一个简单的分析结构值的例子，t。我们创建一个结构，用它的地址创建反射对象，因为我们随后要修改它。然后我们设置typeOfT给它的类型，使用straightforward方法来迭代它的字段。请注意，我们从数据结构类型中提取字段的名字，但是字段本身是一个reflect.Value对象。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;A&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
    &lt;span class="nx"&gt;B&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="nx"&gt;t&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;skidoo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ValueOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;Elem&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="nx"&gt;typeOfT&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NumField&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d: %s %s = %v\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;typeOfT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;Name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Interface&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个程序的输出是：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  0: A int = 23
  1: B string = skidoo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还有一个关于可设置的在这里介绍：T的字段名是大写的（导出特性），因为只有数据结构中导出的字段是可设置的。
  因为S包含一个可设置的反射对象，所以我们可以修改该结构的字段值。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;SetInt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;77&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;SetString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Sunset Strip&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;t is now&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么这里的结果就是：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  t is now {77 Sunset Strip}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果我们修改程序，s从t创建而不是&amp;amp;t，那么调用SetInt以及SetString将会失败，因为t的字段不似乎可设置的。&lt;/p&gt;
&lt;h2&gt;结论：&lt;/h2&gt;
&lt;p&gt;这里重新罗列下反射的规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;反射是从interface value到反射对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反射是从反射对象到interface value&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改一个反射对象，value必须是可设置的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一旦你了解这些反射的规则，它们会变得更加的容易使用，但是它们仍然是很微妙的。因此应该小心的使用，除非你特别需要它才去使用它。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Seanchann Zhou</dc:creator><pubDate>Sun, 07 Jun 2015 00:00:00 +0800</pubDate><guid>tag:seanchann.github.io,2015-06-07:go-reflect-cn.html</guid><category>go</category></item></channel></rss>