<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on seanchann</title>
    <link>https://blog.ucatch.me/tags/golang/</link>
    <description>Recent content in Golang on seanchann</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <managingEditor>seanchann@foxmail.com (Some Person)</managingEditor>
    <webMaster>seanchann@foxmail.com (Some Person)</webMaster>
    <lastBuildDate>Mon, 31 Jul 2017 08:49:41 +0800</lastBuildDate>
    
	<atom:link href="https://blog.ucatch.me/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Reflect</title>
      <link>https://blog.ucatch.me/post/golang/reflect/</link>
      <pubDate>Mon, 31 Jul 2017 08:49:41 +0800</pubDate>
      <author>seanchann@foxmail.com (Some Person)</author>
      <guid>https://blog.ucatch.me/post/golang/reflect/</guid>
      <description>反射规则 原文地址
反射规则的第一条： 1.反射从interface的value到reflection object 在底层，反射仅仅是一个机制，来检查存储在内部的一个interface变量中的type和value的对。首先，在包reflect中有两种类型我们必须知晓：Type 以及 Value。这两个类型可以让我们访问到interface变量的内容，并且提供了两个简单的函数，reflect.TypeOf以及reflect.ValueOf,通过对这两个函数的调用就可以获取到interface变量的值。（此外，调用reflect.Value也非常容易获取到reflect.Type,但是在概念上Value以及Type是完全不同的）
让我们先开始使用下TypeOf:
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;reflect&amp;quot; ) func main() { var x float64 = 3.4 fmt.Println(&amp;quot;type:&amp;quot;, reflect.TypeOf(x)) }  这个程序会打印：
type: float64  你可能会想知道我们的interface在哪里，因为上面的程序看上去就像是它传递了float64给变量x，而不是一个interface的value，传递给我们的reflect.TypeOf。但是它确实是存在的；在godoc文档中，reflect.TypeOf的签名包含一个空的interface：
// TypeOf returns the reflection Type of the value in the interface{}. func TypeOf(i interface{}) Type  当我们调用reflect.TypeOf(x),x是第一个被存储在空interface中，然后传入作为参数；reflect.TypeOf打开这个空的interface，然后重新获取type的信息。
reflect.Valueof 函数，当然，也重新获取value
var x float64 = 3.4 fmt.Println(&amp;quot;value:&amp;quot;, reflect.ValueOf(x))  程序输出：
value: &amp;lt;float64 Value&amp;gt;  reflect.Type以及reflect.Value两个都提供了很多的方法让我们去检查和操作它们。一个重要的例子是Value有一个Type的方法来返回一个reflect.Value的Type。还有Type以及Value都有一个Kind的方法，这个方法返回一个恒量，这个恒量是按照一定的顺序被存储：Unit，Float64，Slice，等等。另外Value提供了一些方法，这些方法名类似Int以及Float，可以让我们获取在这些对象的内部存储的值：（就像int64以及float64）：
var x float64 = 3.</description>
    </item>
    
    <item>
      <title>mongodb客户端 - Go中的并发</title>
      <link>https://blog.ucatch.me/post/mongodb/mongodb-go-concurrently/</link>
      <pubDate>Mon, 31 Jul 2017 08:49:41 +0800</pubDate>
      <author>seanchann@foxmail.com (Some Person)</author>
      <guid>https://blog.ucatch.me/post/mongodb/mongodb-go-concurrently/</guid>
      <description>mongodb中的golang的并发 系统：CentOS7 + docker 1.6
mongodb版本： 3.0.2
原文的地址
pla，pla的一堆作者的铺垫介绍略过，但是还是感谢下作者。
介绍 mongodb支持很多不同的编程语言，感谢编写驱动程序的人员。一个mongoDB的go语言的驱动叫做mgo。这个驱动是由Gustavo Niemeyer和一些的MongoDB公司的同事一起开发的。团队的负责人是Gustavo以及Steve Francia，他们在2014年的“GopherCon”上分享了“使用Go语言在mongodb中存储数据”。分享内容描述了mgo驱动如何使得mongodb和go更好的协同工作去构建高度可扩展的软件。
MongoDB和Go让你可以构建可扩展的软件在很多不同的操作系统以及架构上，无需安装框架或者其他的运行时依赖。Go程序是本地的二进制文件并且Go工具正在不断的提升它的运行效率，它的效率是可以比肩C编写的程序的。但是，这并不意味着如果用Go写程序就很复杂和繁琐，就像C程序那样的。使用Go的情况是，编写代码的速度会很快，并且很有乐趣。
在这篇文章中，我将告诉你如何编写一个Go程序使用mgo驱动来连接以及进行mongo数据库的查询。我会给出一些示例代码，这里可能在新版本的mongodb和Go一同工作上会有一点困惑，但是我会一一解释的。
示例程序 示例程序连接到一个公共的mongodb数据库。如果你有Go和Bazaar在你的机器上安装了，你也可以连接到我的数据库上。这个程序非常的简单 - 它运行了10个goroutines，它们分别会从goinggo数据库中的buoy_stations 集合中查询记录。这些记录被反射到本地的Go types并且每一个goroutine 日志输出返回的文档的数目：
// This program provides a sample application for using MongoDB with // the mgo driver. package main import ( &amp;quot;labix.org/v2/mgo&amp;quot; &amp;quot;labix.org/v2/mgo/bson&amp;quot; &amp;quot;log&amp;quot; &amp;quot;sync&amp;quot; &amp;quot;time&amp;quot; ) const ( MongoDBHosts = &amp;quot;ds035428.mongolab.com:35428&amp;quot; AuthDatabase = &amp;quot;goinggo&amp;quot; AuthUserName = &amp;quot;guest&amp;quot; AuthPassword = &amp;quot;welcome&amp;quot; TestDatabase = &amp;quot;goinggo&amp;quot; ) type ( // BuoyCondition contains information for an individual station.</description>
    </item>
    
  </channel>
</rss>